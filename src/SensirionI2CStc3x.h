/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * I2C-Generator: 0.2.0
 * Yaml Version: 0.1.1
 * Template Version: 0.6.0
 */
/*
 * Copyright (c) 2021, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SENSIRIONI2CSTC3X_H
#define SENSIRIONI2CSTC3X_H

#include <Wire.h>

#include <SensirionCore.h>

class SensirionI2CStc3x {

  public:
    SensirionI2CStc3x();
    /**
     * begin() - Initializes the SensirionI2CStc3x class.
     *
     * @param serial Arduino stream object to be communicated with.
     *
     */
    void begin(TwoWire& i2cBus);

    /**
     * setBinaryGas() - The STC3x measures the concentration of binary gas
    mixtures. It is important to note that the STC3x is not selective for gases,
    and it assumes that the binary gas is set correctly. The sensor can only
    give a correct concentration value when only the gases set with this command
    are present. When the system is reset, or wakes up from sleep mode, the
    sensor goes back to default mode, in which no binary gas is selected. This
    means that the binary gas must be reconfigured. When no binary gas is
    selected (default mode) the concentration measurement will return undefined
    results. This allows to detect unexpected sensor interruption (e.g. due to
    temporary power loss) and consequently reset the binary gas to the
    appropriate mixture.
     *
     * @param binaryGas See section 3.3.2 in the corresponding datasheet for a
    list of available binary gases. STC31: - 0x0000: CO₂ in N₂ for range in 0 to
    100 vol% - 0x0001: CO₂ in air for range in 0 to 100 vol% - 0x0002: CO₂ in N₂
    for range in 0 to 25 vol% - 0x0003: CO₂ in air for range in 0 to 25 vol%
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setBinaryGas(uint16_t binaryGas);

    /**
     * setRelativeHumidity() - As mentioned in section 5.1 of the datasheet, the
    measurement principle of the concentration measurement is dependent on the
    humidity of the gas. With the set relative humidity command, the sensor uses
    internal algorithms to compensate the concentration results. When no value
    is written to the sensor after a soft reset, wake-up or power-up, a relative
    humidity of 0% is assumed. The value written to the sensor is used until a
    new value is written to the sensor
     *
     * @param relativeHumidityTicks Convert %RH to value by: RH * (2^16 - 1) /
    100
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setRelativeHumidity(uint16_t relativeHumidityTicks);

    /**
     * setTemperature() - The concentration measurement requires a compensation
    of temperature. Per default, the sensor uses the internal temperature sensor
    to compensate the concentration results. However, when using the SHTxx, it
    is recommended to also use its temperature value, because it is more
    accurate. When no value is written to the sensor after a soft reset, wake-up
    or power-up, the internal temperature signal is used. The value written to
    the sensor is used until a new value is written to the sensor.
     *
     * @param temperatureTicks Convert °C to value by: T * 200
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setTemperature(uint16_t temperatureTicks);

    /**
     * setPressure() - A pressure value can be written into the sensor, for
    density compensation of the gas concentration measurement. It is recommended
    to set the pressure level, if it differs significantly from 1013mbar.
    Pressure compensation is valid from 600mbar to 1200mbar. When no value is
    written to the sensor after a soft reset, wake-up or power-up, a pressure of
    1013mbar is assumed. The value written is used until a new value is written
    to the sensor.
     *
     * @param absoluePressure Ambient pressure in mbar (milli-bars)
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setPressure(uint16_t absoluePressure);

    /**
     * measureGasConcentration() - The measurement of gas concentration is done
    in one measurement in a single shot, and takes less than 66ms. When
    measurement data is available, it can be read out by sending an I2C read
    header and reading out the data from the sensor. If no measurement data is
    available yet, the sensor will respond with a NACK on the I2C read header.
    In case the ‘Set temperature command’ has been used prior to the measurement
    command, the temperature value given out by the STC3x will be that one of
    the ‘Set temperature command’. When the ‘Set temperature command’ has not
    been used, the internal temperature value can be read out. During product
    development it is recommended to compare the internal temperature value of
    the STC3x and the temperature value of the SHTxx, to check whether both
    sensors are properly thermally coupled. The values must be within 0.7°C.
     *
     * @note The Gas concentration is a 16-bit unsigned integer. The temperature
    and byte 7 and 8 don’t need to be read out. The read sequence can be aborted
    after any byte by a NACK and a STOP condition. The measurement command
    should not be triggered more often than once a second.
     *
     * @param gasTicks Gas concentration. Convert to val % by 100 * (value -
    2^14) / 2^15
     *
     * @param temperatureTicks Temperature. Convert to °C by value / 200
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t measureGasConcentration(uint16_t& gasTicks,
                                     uint16_t& temperatureTicks);

    /**
     * forcedRecalibration() - Forced recalibration (FRC) is used to improve the
     * sensor output with a known reference value. See the Field Calibration
     * Guide for more details. If no argument is given, the sensor will assume a
     * default value of 0 vol%. This command will trigger a concentration
     * measurement as described in 3.3.6 of the datasheet and therefore it will
     * take the same measurement time.
     *
     * @param referenceConcentration Reference concentration
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t forcedRecalibration(uint16_t referenceConcentration);

    /**
     * enableAutomaticSelfCalibration() - Enable the automatic self-calibration
    (ASC). The sensor can run in automatic self-calibration mode. This mode will
    enhance the accuracy for applications where the target gas is not present
    for the majority of the time. See the Field Calibration Guide for more
    details. This feature can be enabled or disabled by using the commands as
    shown below. The automatic self-calibration is optimized for a gas
    concentration measurement interval of 1s. Substantially different
    measurement intervals may decrease the self-calibration performance. The
    default state is disabled. Automatic self-calibration in combination with
    sleep mode requires a specific sequence of steps. See section 3.3.9 in the
    datasheet for more detailed instructions
     *
     * @note The sensor will apply automatic self-calibration
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t enableAutomaticSelfCalibration(void);

    /**
     * disableAutomaticSelfCalibration() - Disable the automatic
    self-calibration (ASC). The sensor can run in automatic self-calibration
    mode. This mode will enhance the accuracy for applications where the target
    gas is not present for the majority of the time. See the Field Calibration
    Guide for more details. This feature can be enabled or disabled by using the
    commands as shown below. The default state is disabled.
     *
     * @note The sensor will not apply automatic self-calibration. This is the
    default state of the sensor.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t disableAutomaticSelfCalibration(void);

    /**
     * prepareReadState() - The sensor will prepare its current state to be read
     * out.
     *
     * @note See section 3.3.9 of the datasheet for detailed instructions.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t prepareReadState(void);

    /**
     * setSensorState() - Write the sensor state as read out earlier.
     *
     * @param state Current sensor state
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t setSensorState(const uint8_t state[], uint8_t stateSize);

    /**
     * getSensorState() - Read out the sensor state.
     *
     * @param state Current sensor state
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t getSensorState(uint8_t state[], uint8_t stateSize);

    /**
     * applyState() - The sensor will apply the written state data.
     *
     * @note See section 3.3.9 of the datasheet for detailed instructions.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t applyState(void);

    /**
     * selfTest() - The sensor will run an on-chip self-test. A successful
    self-test will return zero. The 16-bit result of a sensor self-test is a
    combination of possible error states, encoded as bits (starting with lsb):
    Bits | Error State ------------------------------- 0-1: | Memory error 2  :
    | VDD out of range 3-8: | Measurement value error
    ------------------------------- In case of a successful self-test the sensor
    returns 0x0000 with correct CRC.
     *
     * @param selfTestOutput Self test result. Error code or 0x0000 on success.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t selfTest(uint16_t& selfTestOutput);

    /**
     * enterSleepMode() - Put sensor into sleep mode.
    In sleep mode the sensor uses the minimum amount of current. The mode can
    only be entered from idle mode, i.e. when the sensor is not measuring. This
    mode is particularly useful for battery operated devices. To minimize the
    current in this mode, the complexity of the sleep mode circuit has been
    reduced as much as possible, which is mainly reflected by the way the sensor
    exits the sleep mode. The sleep command can be sent after the result have
    been read out and the sensor is in idle mode. The sensor exits the sleep
    mode and enters the idle mode when it receives the valid I2C address and a
    write bit (‘0’). Note that the I2C address is not acknowledged. It is
    possible to poll the sensor to see whether the sensor has received the
    address and has woken up. This takes maximum 12ms.
     *
     * @note Only available in idle mode
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t enterSleepMode(void);

    /**
     * prepareProductIdentifier() - Prepare for reading the product identifier
     * and sensor serial number.
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t prepareProductIdentifier(void);

    /**
     * readProductIdentifier() - Read the product identifier and sensor serial
    number.
     *
     * @note Make sure to call 'prepare product identifier' immediately before.
     *
     * @param productNumber 32-bit unique product and revision number. The
    number is listed below: STC31: 0x08010301
     *
     * @param serialNumber 64-bit unique serial number
     *
     * @return 0 on success, an error code otherwise
     */
    uint16_t readProductIdentifier(uint32_t& productNumber,
                                   uint8_t serialNumber[],
                                   uint8_t serialNumberSize);

  private:
    TwoWire* _i2cBus = nullptr;
};

#endif /* SENSIRIONI2CSTC3X_H */
