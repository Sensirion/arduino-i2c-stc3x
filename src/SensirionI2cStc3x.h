/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * Generator:     sensirion-driver-generator 0.38.1
 * Product:       stc3x
 * Model-Version: 1.0.0
 */
/*
 * Copyright (c) 2024, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SENSIRIONI2CSTC3X_H
#define SENSIRIONI2CSTC3X_H

#include <SensirionCore.h>
#include <Wire.h>

#define STC31_C_I2C_ADDR_29 0x29
#define STC31_I2C_ADDR_29 0x29

// binary gas < 0x10
#define STC31_MEASUREMENT_DELAY_LOW 66
// binary gas >= 0x10
#define STC31_MEASUREMENT_DELAY_HIGH 110

typedef enum {
    STC3X_SET_BINARY_GAS_CMD_ID = 0x3615,
    STC3X_SET_RELATIVE_HUMIDITY_RAW_CMD_ID = 0x3624,
    STC3X_SET_TEMPERATURE_RAW_CMD_ID = 0x361e,
    STC3X_SET_PRESSURE_CMD_ID = 0x362f,
    STC3X_MEASURE_GAS_CONCENTRATION_RAW_CMD_ID = 0x3639,
    STC3X_FORCED_RECALIBRATION_CMD_ID = 0x3661,
    STC3X_ENABLE_AUTOMATIC_SELF_CALIBRATION_CMD_ID = 0x3fef,
    STC3X_DISABLE_AUTOMATIC_SELF_CALIBRATION_CMD_ID = 0x3f6e,
    STC3X_PREPARE_READ_STATE_CMD_ID = 0x3752,
    STC3X_READ_SENSOR_STATE_CMD_ID = 0xe133,
    STC3X_WRITE_SENSOR_STATE_CMD_ID = 0xe133,
    STC3X_APPLY_STATE_CMD_ID = 0x3650,
    STC3X_SELF_TEST_CMD_ID = 0x365b,
    STC3X_PREPARE_PRODUCT_IDENTIFIER_CMD_ID = 0x367c,
    STC3X_READ_PRODUCT_IDENTIFIER_CMD_ID = 0xe102,
    STC3X_ENTER_SLEEP_MODE_CMD_ID = 0x3677,
    STC3X_EXIT_SLEEP_MODE_CMD_ID = 0x0,
    STC3X_ENABLE_WEAK_FILTER_CMD_ID = 0x3fc8,
    STC3X_DISABLE_WEAK_FILTER_CMD_ID = 0x3f49,
    STC3X_ENABLE_STRONG_FILTER_CMD_ID = 0x3fd5,
    STC3X_DISABLE_STRONG_FILTER_CMD_ID = 0x3f54,
} STC3xCmdId;

typedef union {
    struct {
        uint16_t memoryError : 2;
        uint16_t vddOutOfRange : 1;
        uint16_t measurementValueError : 6;
        uint16_t temperatureError : 1;
    };
    uint16_t value;
} STC3xTestResultT;

class SensirionI2cStc3x {
  public:
    SensirionI2cStc3x();
    /**
     * @brief Initializes the STC3x class.
     *
     * @param i2cBus Arduino stream object to be used for communication.
     */
    void begin(TwoWire& i2cBus, uint8_t i2cAddress);

    /**
     * @brief Set relative humidity for internal compensation of gas
     * concentration.
     *
     * The measurement principle of the concentration measurement is dependent
     * on the humidity of the gas. The new low cross sensitivity mode reduces
     * this sensitivity by smart internal compensation to a minimum. If
     * possible, it is still recommended to compensate for relative humidity and
     * to update the compensation input whenever the relative humidity changes.
     * With the set relative humidity command, the sensor uses the set humidity
     * in the gas model to compensate the concentration results.
     *
     * @param[in] relativeHumidity Relative humidity in percent %.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setRelativeHumidity(float relativeHumidity);

    /**
     * @brief Set temperature for internal compensation of gas concentration.
     *
     * The concentration measurement requires a compensation of temperature. Per
     * default, the sensor uses the internal temperature sensor to compensate
     * the concentration results. However, when using the SHTxx, it is
     * recommended to also use its temperature value, because it is more
     * accurate. The temperature compensation input should be updated whenever
     * the temperature changes.
     *
     * @param[in] temperature Temperature in degree celsius.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setTemperature(float temperature);

    /**
     * @brief measure CO2 gas concentration in vol%.
     *
     * The measurement of gas concentration is done in one measurement in a
     * single shot, and takes less than 66ms. When measurement data is
     * available, it can be read out by sending an I2C read header and reading
     * out the data from the sensor. If no measurement data is available yet,
     * the sensor will respond with a NACK on the I2C read header.
     *
     * @param[out] co2Concentration
     * @param[out] temperature
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t measureGasConcentration(float& co2Concentration,
                                    float& temperature);

    /**
     * @brief Prepare and read sensor state.
     *
     * The sensor stores settings like the Gas Mode or reference values of FRC
     * and ASC in volatile memory. These are not retained when the sensor loses
     * power and must be stored externally to be sent to the sensor after each
     * power cycle. To store the state externally use the methods
     * get_sensor_state and set_sensor_state.
     *
     * The sensor state contains the following information: - Selected binary
     * gas index. - ON or OFF flag and offset value to apply to the sensor's
     * output for the automatic self-calibration. - Offset value to apply to the
     * sensor's output used in forced recalibration. - Compensation inputs: last
     * supplied values of temperature, humidity and pressure
     *
     * @param[out] state Current sensor state
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getSensorState(uint8_t state[], uint16_t stateSize);

    /**
     * @brief write and apply sensor state.
     *
     * The sensor stores settings like the Gas Mode or reference values of FRC
     * and ASC in volatile memory. These are not retained when the sensor loses
     * power and must be stored externally to be sent to the sensor after each
     * power cycle. To store the state externally use the methods
     * get_sensor_state and set_sensor_state.
     *
     * The sensor state contains the following information: - Selected binary
     * gas index. - ON or OFF flag and offset value to apply to the sensor's
     * output for the automatic self-calibration. - Offset value to apply to the
     * sensor's output used in forced recalibration. - Compensation inputs: last
     * supplied values of temperature, humidity and pressure
     *
     * @param[in] sensorState
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setSensorState(const uint8_t sensorState[],
                           uint16_t sensorStateSize);

    /**
     * @brief prepare and read product identifier and serial number
     *
     * Get the 32-bit product identifier and 64-bit sensor serial number. Please
     * check the datasheet to get the expected product identifier for your
     * STC31.
     *
     * @param[out] productId
     * @param[out] serialNumber
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t getProductId(uint32_t& productId, uint64_t& serialNumber);

    /**
     * @brief setBinaryGas
     *
     * The STC3x measures the concentration of binary gas mixtures. It is
     * important to note that the STC3x is not selective for gases, and it
     * assumes that the binary gas is set correctly. The sensor can only give a
     * correct concentration value when only the gases set with this command are
     * present. When the system is reset, or wakes up from sleep mode, the
     * sensor goes back to default mode, in which no binary gas is selected.
     * This means that the binary gas must be reconfigured. When no binary gas
     * is selected (default mode) the concentration measurement will return
     * undefined results. This allows to detect unexpected sensor interruption
     * (e.g. due to temporary power loss) and consequently reset the binary gas
     * to the appropriate mixture.
     *
     * @param[in] binaryGas See section 3.3.2 in the corresponding datasheet for
     * a list of available binary gases.
     *
     * STC31-C:
     *   * 0x0010: CO₂ in N₂ for range in 0 to 100 vol%
     *   * 0x0011: CO₂ in air for range in 0 to 100 vol%
     *   * 0x0012: CO₂ in N₂ for range in 0 to 40 vol%
     *   * 0x0013: CO₂ in air for range in 0 to 40 vol%
     * STC31:
     *   * 0x0000: CO₂ in N₂ for range in 0 to 100 vol%
     *   * 0x0001: CO₂ in air for range in 0 to 100 vol%
     *   * 0x0002: CO₂ in N₂ for range in 0 to 25 vol%
     *   * 0x0003: CO₂ in air for range in 0 to 25 vol%
     *
     * @return error_code 0 on success, an error code otherwise.
     *
     * Example:
     * --------
     *
     * @code{.cpp}
     *
     *     int16_t localError = 0;
     *     localError = sensor.setBinaryGas(19);
     *     if (localError != NO_ERROR) {
     *         return;
     *     }
     *
     * @endcode
     *
     */
    int16_t setBinaryGas(uint16_t binaryGas);

    /**
     * @brief setRelativeHumidityRaw
     *
     * As mentioned in section 5.1 of the datasheet, the measurement principle
     * of the concentration measurement is dependent on the humidity of the gas.
     * With the set relative humidity command, the sensor uses internal
     * algorithms to compensate the concentration results. When no value is
     * written to the sensor after a soft reset, wake-up or power-up, a relative
     * humidity of 0% is assumed. The value written to the sensor is used until
     * a new value is written to the sensor
     *
     * @param[in] relativeHumidityTicks Convert %RH to value by: RH * (2^16 - 1)
     * / 100
     *
     * @return error_code 0 on success, an error code otherwise.
     *
     * Example:
     * --------
     *
     * @code{.cpp}
     *
     *     int16_t localError = 0;
     *     localError = sensor.setRelativeHumidityRaw(32768);
     *     if (localError != NO_ERROR) {
     *         return;
     *     }
     *
     * @endcode
     *
     */
    int16_t setRelativeHumidityRaw(uint16_t relativeHumidityTicks);

    /**
     * @brief setTemperatureRaw
     *
     * The concentration measurement requires a compensation of temperature. Per
     * default, the sensor uses the internal temperature sensor to compensate
     * the concentration results. However, when using the SHTxx, it is
     * recommended to also use its temperature value, because it is more
     * accurate. When no value is written to the sensor after a soft reset,
     * wake-up or power-up, the internal temperature signal is used. The value
     * written to the sensor is used until a new value is written to the sensor.
     *
     * @param[in] temperatureTicks Convert °C to value by: T * 200
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setTemperatureRaw(uint16_t temperatureTicks);

    /**
     * @brief setPressure
     *
     * A pressure value can be written into the sensor, for density compensation
     * of the gas concentration measurement. It is recommended to set the
     * pressure level, if it differs significantly from 1013mbar. Pressure
     * compensation is valid from 600mbar to 1200mbar. When no value is written
     * to the sensor after a soft reset, wake-up or power-up, a pressure of
     * 1013mbar is assumed. The value written is used until a new value is
     * written to the sensor.
     *
     * @param[in] absoluePressure Ambient pressure in mbar (milli-bars)
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t setPressure(uint16_t absoluePressure);

    /**
     * @brief measureGasConcentrationRaw
     *
     * The measurement of gas concentration is done in one measurement in a
     * single shot, and takes less than 66ms. When measurement data is
     * available, it can be read out by sending an I2C read header and reading
     * out the data from the sensor. If no measurement data is available yet,
     * the sensor will respond with a NACK on the I2C read header. In case the
     * ‘Set temperature command’ has been used prior to the measurement command,
     * the temperature value given out by the STC3x will be that one of the ‘Set
     * temperature command’. When the ‘Set temperature command’ has not been
     * used, the internal temperature value can be read out. During product
     * development it is recommended to compare the internal temperature value
     * of the STC3x and the temperature value of the SHTxx, to check whether
     * both sensors are properly thermally coupled. The values must be within
     * 0.7°C.
     *
     * @param[out] gasTicks Gas concentration. Convert to vol % by 100 * (value
     * - 2^14) / 2^15
     * @param[out] temperatureTicks Temperature. Convert to °C by value / 200
     *
     * @note The Gas concentration is a 16-bit unsigned integer. The temperature
     * and byte 7 and 8 don’t need to be read out. The read sequence can be
     * aborted after any byte by a NACK and a STOP condition. The measurement
     * command should not be triggered more often than once a second.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t measureGasConcentrationRaw(uint16_t& gasTicks,
                                       uint16_t& temperatureTicks);

    /**
     * @brief forcedRecalibration
     *
     * Forced recalibration (FRC) is used to improve the sensor output with a
     * known reference value. See the Field Calibration Guide for more details.
     * If no argument is given, the sensor will assume a default value of 0
     * vol%. This command will trigger a concentration measurement as described
     * in 3.3.6 of the datasheet and therefore it will take the same measurement
     * time.
     *
     * @param[in] referenceConcentration Reference concentration
     *
     * @return error_code 0 on success, an error code otherwise.
     *
     * Example:
     * --------
     *
     * @code{.cpp}
     *
     *     int16_t localError = 0;
     *     localError = sensor.forcedRecalibration(0);
     *     if (localError != NO_ERROR) {
     *         return;
     *     }
     *
     * @endcode
     *
     */
    int16_t forcedRecalibration(uint16_t referenceConcentration);

    /**
     * @brief enableAutomaticSelfCalibration
     *
     * Enable the automatic self-calibration (ASC). The sensor can run in
     * automatic self-calibration mode. This mode will enhance the accuracy for
     * applications where the target gas is not present for the majority of the
     * time. See the Field Calibration Guide for more details. This feature can
     * be enabled or disabled by using the commands as shown below. The
     * automatic self-calibration is optimized for a gas concentration
     * measurement interval of 1s. Substantially different measurement intervals
     * may decrease the self-calibration performance. The default state is
     * disabled. Automatic self-calibration in combination with sleep mode
     * requires a specific sequence of steps. See section 3.3.9 in the datasheet
     * for more detailed instructions
     *
     * @note The sensor will apply automatic self-calibration
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t enableAutomaticSelfCalibration();

    /**
     * @brief disableAutomaticSelfCalibration
     *
     * Disable the automatic self-calibration (ASC). The sensor can run in
     * automatic self-calibration mode. This mode will enhance the accuracy for
     * applications where the target gas is not present for the majority of the
     * time. See the Field Calibration Guide for more details. This feature can
     * be enabled or disabled by using the commands as shown below. The default
     * state is disabled.
     *
     * @note The sensor will not apply automatic self-calibration. This is the
     * default state of the sensor.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t disableAutomaticSelfCalibration();

    /**
     * @brief prepareReadState
     *
     * The sensor will prepare its current state to be read out.
     *
     * @note See section 3.3.9 of the datasheet for detailed instructions.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t prepareReadState();

    /**
     * @brief readSensorState
     *
     * Read out the sensor state. The 30 bytes must be stored on the
     * microcontroller to be written back to the sensor after exiting sleep
     * mode.
     *
     * @param[out] state Current sensor state
     *
     * @note See section 3.3.9 of the datasheet for detailed instructions.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t readSensorState(uint8_t state[], uint16_t stateSize);

    /**
     * @brief writeSensorState
     *
     * Write the sensor state. The 30 bytes must be stored on the
     * microcontroller to be written back to the sensor after exiting sleep
     * mode.
     *
     * @param[in] state Current sensor state
     *
     * @note See section 3.3.9 of the datasheet for detailed instructions.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t writeSensorState(const uint8_t state[], uint16_t stateSize);

    /**
     * @brief applyState
     *
     * The sensor will apply the written state data.
     *
     * @note See section 3.3.9 of the datasheet for detailed instructions.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t applyState();

    /**
     * @brief selfTest
     *
     * The sensor will run an on-chip self-test. A successful self-test will
     * return zero. The 16-bit result of a sensor self-test is a combination of
     * possible error states, encoded as bits (starting with lsb):
     *
     *
     * * 0-1: Memory error
     * * 2: VDD out of range
     * * 3-8: Measurement value error
     * * 9: Difference between externally supplied temperature (see 2.3.4) and
     *   internally measured temperatures exceeds the accuracy specifications.
     * In case of a successful self-test the sensor returns 0x0000 with correct
     * CRC.
     *
     * @param[out] selfTestOutput Self test result. Error code or 0x0000 on
     * success.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t selfTest(STC3xTestResultT& selfTestOutput);

    /**
     * @brief prepareProductIdentifier
     *
     * Prepare for reading the product identifier and sensor serial number.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t prepareProductIdentifier();

    /**
     * @brief readProductIdentifier
     *
     * Read the product identifier and sensor serial number.
     *
     * @param[out] productNumber 32-bit unique product and revision number. The
     * number is listed below: STC31: 0x08010301
     * @param[out] serialNumberHigh Higher 32-bit of the 64-bit unique serial
     * number
     * @param[out] serialNumberLow Lower 32-bit of the 64-bit unique serial
     * number
     *
     * @note Make sure to call 'prepare product identifier' immediately before.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t readProductIdentifier(uint32_t& productNumber,
                                  uint32_t& serialNumberHigh,
                                  uint32_t& serialNumberLow);

    /**
     * @brief enterSleepMode
     *
     * Put sensor into sleep mode. In sleep mode the sensor uses the minimum
     * amount of current. The mode can only be entered from idle mode, i.e. when
     * the sensor is not measuring. This mode is particularly useful for battery
     * operated devices. To minimize the current in this mode, the complexity of
     * the sleep mode circuit has been reduced as much as possible, which is
     * mainly reflected by the way the sensor exits the sleep mode. The sleep
     * command can be sent after the result have been read out and the sensor is
     * in idle mode.
     *
     * @note Only available in idle mode
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t enterSleepMode();

    /**
     * @brief exitSleepMode
     *
     * Exit the sleep mode. The sensor exits the sleep mode and enters the idle
     * mode when it receives the valid I2C address and a write bit (‘0’). Note
     * that the I2C address is not acknowledged. It is possible to poll the
     * sensor to see whether the sensor has received the address and has woken
     * up. This takes maximum 12ms.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t exitSleepMode();

    /**
     * @brief Enable weak filter with a smoothing factor of 1/2.5
     *
     * The STC31 has two built-in noise filters that run an exponential
     * smoothing over the past measurement points. By default, no filter is
     * applied to the data. If weak smoothing is desired, the following
     * command(s) must be executed once upon starting the sensor. When enabled,
     * the weak filter is applied for all subsequent concentration measurements.
     *
     * @note
     * * Both filters can be activated at the same time (chained) for stronger
     *   smoothing.
     * * FRC can only benefit from this filtering if sufficient measurement
     * points have been taken before executing the FRC.
     * * The response time (specified in section 1.2) will increase if a noise
     *   filter is applied.
     * * Filtering will not function if the sensor is put to sleep between each
     *   concentration measurement, asthe last output value is lost.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t enableWeakFilter();

    /**
     * @brief disableWeakFilter
     *
     * disable the weak smoothing filter
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t disableWeakFilter();

    /**
     * @brief enable strong filter with smoothing factor of 1/7.5
     *
     * The STC31 has two built-in noise filters that run an exponential
     * smoothing over the past measurement points. By default, no filter is
     * applied to the data. If strong smoothing is desired, the following
     * command(s) must be executed once upon starting the sensor. When enabled,
     * the strong filter is applied for all subsequent concentration
     * measurements.
     *
     * @note
     * * Both filters can be activated at the same time (chained) for stronger
     *   smoothing.
     * * FRC can only benefit from this filtering if sufficient measurement
     * points have been taken before executing the FRC.
     * * The response time (specified in section 1.2) will increase if a noise
     *   filter is applied.
     * * Filtering will not function if the sensor is put to sleep between each
     *   concentration measurement, asthe last output value is lost.
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t enableStrongFilter();

    /**
     * @brief disableStrongFilter
     *
     * disable the strong smoothing filter
     *
     * @return error_code 0 on success, an error code otherwise.
     */
    int16_t disableStrongFilter();

    /**
     * @brief signalTemperature
     *
     * @param[in] rawTemperature
     *
     * @return
     */
    static float signalTemperature(uint16_t rawTemperature);

    /**
     * @brief signalGasConcentration
     *
     * @param[in] rawGasConcentration
     *
     * @return
     */
    static float signalGasConcentration(uint16_t rawGasConcentration);

  private:
    TwoWire* _i2cBus = nullptr;
    uint8_t _i2cAddress = 0;
    uint16_t _measurement_delay = STC31_MEASUREMENT_DELAY_LOW;
};

#endif  // SENSIRIONI2CSTC3X_H